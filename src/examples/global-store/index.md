Всім привіт, мене звати Віталій Рубан, я працюю в компанії Ітера і сьогодні, у нас рубрика React Code Smell в якій ми поговоримо про поширені помилки у використанні глобальних сторів на прикладі нашого улюбленого Redux.

Ми поговоримо про помилки проектування стору, читання зі стору та запису в стор.

Але перед тим як ми перейдемо до відео короткий дисклеймер: Для проектів масштабу мого прикладу системи керування станом, а тим паче Redux не потрібні взагалі. Розглядайте мій приклад як частину суттєво більшого проекту. Інлайн стилі використовуються для простоти, цей підхід на реальному проекті не правильний.

Отже, починаємо.

<!-- ПАУЗА -> НА ЕКРАНІ ЗАСТОСУНОК -->

В якості прикладу я підготував невеликий застосунок на одну сторінку. Все що в ньому є - ТОП-5 ігор за версією метакритик з можливістю пошуку. Кожна гра має опис який можна відкрити або згорнути. Ще є умовна навігація з іменем користувача. Як бачите все просто і навіть начебто працює. Тепер давайте подивимось на код.

Код складається з:

- лейауту в якому ініціалізується стор, лежить навігація та аутлет
- глобального стору написаного за допомогою redux-toolkit
- сторінки gamePage з відповдіними компонентами
- сторінки achievements з відповідними компонентами

Коду в нас не багато, а от код-смелів вистачає, то ж, переходимо до них.

Почнемо з проектування стору.

## Код смелл №1 використання єдиного глобального стору для всього застосунку

Давайте подивимось на те, як виглядає наш стор.

<!-- ПАУЗА -> ВІДКРИЙ `global.store.js` -->

Стор складається з єдиного слайсу в якому я тримаю дані користувача, ігри, досягнення, слово для фільтрації та відфільтровані ігри. Як бачите в мене є щонайменше два набори даних які між собою взагалі не пов'язані - це ігри і користувач. Тримати їх в одному місці немає жодної потреби, це зайве переускладення стору, тим паче, що в redux toolkit є інструмент, призначений для розрізання стору на не залежні шматки - `createSlice`. Використвуйте createSlice для того щоб розділити ваш стор на логічно не залежні частини. Це зменшить крихкість стору,полегшить його читання та підтримку, ще й швидкодію може покращити.

Для того щоб визначити не залежні частини даних - достатньо поставити запитання чи повинні ці дані змінюватися коли змінюються якийсь іншій набір даних. Наприклад, чи мають змінюватися дані користувача, якщо змінюються відфільторані ігри? Напевно - ні. Отже ці дані не залежні і можуть бути винесені в окремий слайс.

Якщо ви використовуєте інші системи керування станом, наприклад MobX - достатньо створювати окремі стори для незалежних один від одного наборів даних.

До-речі, тримання слайсів в одному файлі це теж код смел, але я впевнений що ви це розумієте і без мене.

Тепер давайте розберемо код смели під час читання зі стору.

<!-- ПАУЗА -> ВІДКРИЙ `nav.jsx` -->

## Код смел №2 отимання всього слайсу в useSelector, або залежність від усього стору.

Цей код смелл дуже простий як для розуміння так і для виправлення. Давайте подивимось на компонент Nav.

Як бачите, для роботи цьому компоненту потрібен `user`. Замість того щоб отримати лише користувача зі стору, мій компонент отримує взагалі весь стор, а вже потім отримує з нього дані користувача.

Недолік цього підходу - швидкодія. Оскільки цей компонент залежить від усього стору, то й перерендерюватися він буде на будь-яку зміну цього самого стору. Для демонстрації цієї проблеми я додав в код компоненту трохи зайвої, довготривалої роботи.

Давайте подивимось на приклад.

<!-- ПАУЗА -> ВІДКРИЙ ЕКРАН -->

Пробуємо зробити пошук і, як бачите, все працює дуже повільно.

Виправити цей код дуже просто. Змінюємо useSelector так, щоб замість всього стору ми отримували лише `userName`.

Пробуємо знову і все працює як треба, nav не перерендерюються, а застосунок працює без затримок, незважаючи на те, що важкий код нікуди не дівся. А якщо у вас не redux toolkit і немає useSelector ви можете скористатися бібліотекою `reselect`.

Додатково, ми можемо винести функцію отримання даних зі стору з компоненту і все буде навіть ще швидше.

## Код смел № 3 - використання Store замість Props

Ще одну, досить очевидну помилку можна побачити в компоненті `Game` яка полягає у надлишковому використанні стору. У нас є компонент Game який одночасно вміє дістати дані зі стору і відмалювати їх. Це порушення принципу єдиної відповідальності, яке призвело до зайвого ускладення коду та збільшення зв'язності коду, оскільки наш Game тепер знає про стор і має певну логіку по отриманні даних зі стору.

Замість цього ми могли б просто використати Props щоб отримати необхідні для компоненту дані. Таким чином цей компонент стане незалежним та більш універсальним і зможе використовувати дані з будь-якого джерела.

За можливості, краще використовувати пропси замість стору, або хоча б розділяти компоненти на ті які вміють отримувати дані і ті які вміють їх використовувати. Як не дивно, HighOrderComponents досі живі, не дивлячись на очевидну перемогу хуків, саме тому що допомагаються тримати презентаційні компоненти вільними від зайвої логіки.

А, що робити, якщо моєму компонентові потрібно дуже багато даних і пропси виростають до монструозних розмірів? В такому випадку, скоріше за все, ваш компонет занадто складний і потребує розбиття на складові. Пам'ятайте, що сила реакту в маленких компонентах. 700 рядків на один компонент то шлях страждань, а не самурая.

Тепер давайте розглянемо код смели під час запису в стор.

<!-- ПАУЗА -> ВІДКРИЙ `expand-collapse.jsx` -->

## Код смел №4 - Збереження локального стану в глобальному сторі

Маємо комопонент експанд коллапс, який відмальовує опис гри і використовує глобальний стор для збереження свого стану. Давайте на секунду зробимо паузу і подумаємо, які проблеми це нам приносить?

<!-- ПАУЗА -->

Особисто я бачу тут декілька проблем.

По-перше, загальний компонент більше не є самостійним. Ми не можемо просто так взяти і перевикористати його, оскільки він обов'язково потребує конкретний стор і конкретний ред'юсер для своєї роботи. Збільшується зв'язність коду.

По-друге, стан цього компоненту відкритий усьому світу - будь-хто може змінити цей стан за допомогою ред'юсеру `toggleExpandedReducer`. Порушується інкапсуляція.

По-третє, у нас ускладнюється глобальний стор. Коду стає більше, читати стає складніше, вірогідність щось зламати зростає. Код стає більш крихким.

В-четверте - перформанс. Використання глобального стору завжди дорожче за локальний.

І все це ми міняємо на можливість керування цим компонентом з-під стору, яка нам і не потрібна.

Виправити це просто - достатньо використасти звичайний useState замість глобального стору. Це просте рішення вирішує всі перелічені проблеми одразу. Не нехтуйте useState, він і досі чудовий.

А от що робити, якщо нам все ж таки потрібне керування експенд коллапс з-під стору? (наприклад мені потрібна кнопка як відкриє одразу усі секції?) В таком разі я раджу розбити цей компонент на два - перший компонент буде тримати лише відобрежання, а другий буде зберігати стейт. Це дозволить нам використовувати один і той самий компонент з відображенням з будь-яким способом зберігання даних.

<!-- ПАУЗА -> ВІДКРИЙ ЕКРАН -->

## Код смелл № 5 - робота з формою через redux

Незважаючи на те, що цей код смел дуже схожий на попередній я все ж таки виніс його окремо через поширеність та більшу небезпеку. Сам код смел полягає в тому, що ми кожну зміну нашої форми в глобальний стор. Додали літеру, смикнули стор, видалили літеру, смикнули стор. Це має декілька негативних наслідків.

По-перше нам потрібні редьюсери на всі поля форми, а це зайвий код (так я знаю що для цього є бібліотеки, але не потрібно вирішувати проблеми, яких можна взагалі уникнути).

По-друге, це може бути досить дорого з точки зору швидкодії - викликати глобальний стейт на зміну кожної літери не найкраща в світі ідея. Яким би швидким реакт не був, не факт що він зможе це витримати і ваші інпуту просто почнуть тормозити. Дуже не приємно, коли ти натискаєш на кнопку клавіатури а ще 300 мілісекунд нічого не вібдбувається.

Рішення тут дуже просте. Поки користувач заповнює форму - ми зберігаємо її дані локально. Коли ж він робить сабміт - ми відправляємо їх за призначенням: або в глобальний стор, якщо ці дані десь потрібні десь ще в застосунку, або просто на сервер, якщо вони більше ніде не потрібні. От і все - просто \_\_ не смикай \_\_ стор.

<!-- ПАУЗА -> ВІДКРИЙ `game.page.jsx` -->

## Код смелл №6 - збереження псевдолокального стану в глобальному сторі.

Наступний приклад більш цікавий та складний. На сторінці game я маю компонент search, який записує ключове слово для пошуку в глобальний стор. Це ж слово я показую вже в іншому компоненті `SearchText` нижче. Як бачите, наш стейт `SearchText` більше не є локальним, але чи доцільно зберігати його в глобальному сторі? З однієї сторони це досить зручно для використання та рефакторингу. Це безумовно плюс. Ще один плюс полягає в тому, що могли б налаштувати стор на отримання ігор з серверу на зміну SearchText і це відбувалося б прозоро для нашого застосунку.

З іншої сторони, в моєму прикладі, і пошукове слово, і список ігор потрібні лише тим компонентам що лежать дуже поруч і нікому іншому. Чи варто, в цьому випадку, викладати дані в стор? На мою думку все ще ні, ми цілком можемо обійтися локальним стейтом в батьківському компоненті, або ж, хоча б створити окремий слайс для цих даних, якщо, УВАГА, ви очікуєте ускладнення цієї логіки. Але якщо дані потрібні лише батьку та його нащадку, useState - абсолютно прийнятне рішення.

Як бачите, не всі рішення є однозначно поганими або хорошими. Але, проектуючи систему пам'ятайте, що кожне ускладнення має приносити конкретну користь. Не переускладнюйте код наперед.

<!-- ПАУЗА -> ВІДКРИЙ `global.store.js` -->

## Код смелл № 7 Збереження похідних даних в глобальному сторі

Ще одним популярним CodeSmell є збереження похідних даних у стейті або сторі. Якщо подивитись на reducer `searchGame` ми побачимо, що він не просто записує в стор пошукове слово, а, ще й виконує фільтрацію ігор. А, оскільки ми не можемо використовувати поле allGames, тому я змушений був завести додатковое поле `filteredGames` для тих елементів які прошли фільтрацію. Це роздуває наш стор, ускладнює його використання, збільшує обсяг пам'яті який потрібен нашому застосунку для роботи. І, якщо зараз мій стор все ще досить маленький, то уявіть собі що станеться коли в мене таких редьсюреів буде два десятка.

Для того що б це виправити ми можемо винести функцію фільтрації зі стору, а саму фільтрацію зробити в компоненті. Це дасть нам можливість в подальшому перевикористати цю функцію та протествувати її, якщо там буде складна логіка.

Єдине застереження не робіть фільтрацію в самому `useSelector`. Оскільки `.filter` постійно повертає новий екземпляр масиву, оптимізація закладена в useSelector не спрацює і компонент буде перерендерюватися постійно з будь-якою зміною стору. Що власне є ще одним маленьким, але поширеним одним код-смеллом.

## Код смелл № 8 - використання інструментів для асинхронних дій для синхроного коду

Цей код смел більше стосується чистого Redux, без Redux toolkit і в мене цього прикладу немає, але він настільки простий що приклад нам і не потрібен. Як ви знаєте, "голий" Redux не вміє в асинхронну логіку і для того щоб це вирішити ми використовуємо Саги або Санки. А сам код смел полягає у використанні їх для усієї логіки як асинхронної так і звичайної, синхронної, що призводить до ускладення коду і погіршення швидкодії. На щастя redux toolkit йде одразу з React Query, що зменшую ваші шанси зустріти цю проблему

## Підведемо підсумки

Глобальний стор річ корисна, але має тенденцію до розростання та ускладнення. Для уникненнця цього - використовуйте глобальний стор лише для тих даних, які потрібні у всьому застосунку. Не забувайте розділяти стор на логічні шматки. Не використовуйте стор для похідних даних. Пишіть селектори, які отримують зі стору мінімально потрібний набір даних.

Приклади коду ви можете знайти під описом до цього відео, там же є і посилання на наш телеграм канал.

На цьому у мене все, бережіть себе, допомагайте ЗСУ і скоро побачимось!
