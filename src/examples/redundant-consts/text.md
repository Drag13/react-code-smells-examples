Всім привіт, вітаю вас на каналі React для початківців. Мене звати Віталій Рубан, я працюю в компанії Itera і сьогодні у нас рубрика React Code Smells.

Давайте поговоримо про простий, але дуже розвосюджений Code Smell - створення константних констуркцій під час рендеру. Можливо це звучить складно, але мова йде про створення констант та функцій прямо в самомум react комопоненті

Сьогодняшним прикладом нам буде слугувати шматочок гри хрестики нулики. Поїхали!

І почнемо ми з першого код смелу - використання магічних констант. Цей, аромат, характерний не лише для React, а й взагалі для будь-якої іншої мови програмування. Його головна проблема в тому, що ви не можете з першого або навіть другого погляду зрозуміти що конкретно ця константа означає. Треба вчитуватися в код де ця магія використовується, можливо дивитися контекст і так далі. Ось вам приклад, спробуйте з першого погляду зрозуміти що означає цифра 3.

---

Виправити цей код смелл - просто достатньо дати цій константі якесь зрозуміле ім'я.

Наприклад MATRIX_WIDTH

Не зайвим буде також винести константу з межі компоненту на рівень модуля або взагалі в файл конфігурації. Або,для React є і другий варіант - прийняти цю змінну в якості пропсів, що зробить наш компонент більш гнучким та відкритим для зміни поведінки.

Тепер давайте перейдемо до другого код смелу, вже більш характерного для React - створення константних об'єктів під час рендеру компонент. Але перед цим, давайте пригадаємо, що коли ви змінюєте стейт компоненту, код цього компоненту і його дочірні не оптиммізовані компоненти перевикливаються (ще говорять - перерендерюються). Іншими словами setState заново викликає код свого власника і код дочірніх не оптимізованих компонентів. Якщо вся ваша апка зроблена з неоптимізованих компонентів, то викликаючи setState в рутовому компоненті ви перевикличете абсолютно всі ваші компоненти.

Тепер нам буде не важко зрозуміти що не так з кодом на п'ятому рядку. На кожен setState ми створюємо новий масив з 9и елементів, що збільшує споживання пам'ятів вашим застосунком, навантажуєе CPU, навантажує Garbage Collector. Зрозуміло, що на цьому прикладу ми це навіть не помітимо, але, якщо цей код смелл розповзеться по великому застосунку з великою кількістю перерендрів це може стати помітно. Найцікавіше, що нові масиви нам взагалі не потрібні, тому що useState ініціалізується один єдиний раз ігноруючи всі подальші його виклики.

Друга проблема полягає в тому, що вся ця робота з масивами захаращує код самого компоненту, роздувчаючи його і ускладнюючи читання. Нащастя вирішити цю проблему дуже просто - достатньо винести створення цього масиву за межі компоненту, а якщо робити все, як то кажуть по феншую, то огорнути цей код в окрему функцію, наприклад ось так:

Аналогічна історія з функціями які наче і належать компоненту, але є чистими - тобто такими що завжди повертають один і той самий результат для одного й того самого набору вхідих параметрів і не мають побічних ефектів. Чисті функції це трохи інша тема, наразі просто ставтеся до них як до коду, який залежить лише від вхідних параметрів. Проблема з ними абсолютна та сама що й зі звичайними константами. Вони роздувають код і споживають рерурси. Але їх винос в окремий файл має додаткову перевагу, оскільки дає можливіть таку функцію протестувати та, за необхідності, перевикористати.

А, тепер давайте перейдемо до найцікавішого код смелу - створення компонентів всередині інших компонентів. Виглядає це наче й непогано - така собі інкапсуляція на рівні компоненту. Але, як то кажуть, є нюанс. І для того щоб продемонструвати цей нюанс я зробив мікрохук який пише в консоль текст, якщо компонент до якого він належить unmountиться, тобто повністю видаляється з DOM, що є не дуже дешевою операцією. Якщо порівнювати, то render компоненту коштує десь як мівіна, а unmount десь як повноцінний похід в кафешку. Не космос, але кожен день не находишся. І ось тут реакт може зробити всім сюрприз. Давайте подивимось.

Тобто, як бачите, створення компонентів в середині компонентів не тільки має всі попередні недоліки, але й може заставити нас заплатити непоганий такий чек, особливо, якщо в середині цих компонентів є виклик бекенду. Власне, наразі цей спосіб у мене на другому місті в категорії як вбити перформанс вашої апки.

Доречі, в цьому відео ми примудрились розглянути три з п'яти складових одного дуже заїзженого, але корисного принципу. Спробуйте вгадати в коментарях - якого!

На цьому у мене все, бережіть себе і скоро побачимось!

У цього код смелу є 4 симптоми і ми почнемо з найпростішого:

1. Захардкоджені константи - проблема: магічні числа, ускладнена підтрима (потрібно два використання)
2. Захардкоджені об'єкти і масиви - проблема: зайве використання ресусрів, збільшення коду самого компоненту що ускладнює його читання, неможливість оптимізації нащадків.
3. Захардкоджені чисті функці - проблема: див попередній пункт + збереження логіки безпосередньо в UI компоненті
4. Захардкоджені комопненти - те саме плюс постіний unmount

Давайте подивимось на код.
