Всім привіт, вітаю вас на каналі React для початківців. Мене звати Віталій Рубан, я працюю в компанії Itera і сьогодні у нас рубрика React Code Smells.

Давайте поговоримо про хук useCallback і про те, як його використовують не правильно.

Для початку давайте розберемося, що взагалі робить хук useCallback. Його головна ідея - повертати один і той самий екземпляр функції для сталого набору залежностей. Тобто, цей хук в першу чергу призначений для оптимізацій швидкодії. Але, як і будь-яка оптимізація він може чудово нашкодити. Тому давайте до прикладів.

Почнемо з огляду з демосторінки. Як бачите ми маємо:

- Функціональний компонент у вигляді кнопки
- Сет із чотирьох звичайних кнопок
- Ще одна кнопка в формі функціонального компоненту, але якось оптимізована
- Ну і каунтер для того щоб ми могли запустити ре-рендер і бачити як реагує застосунок на наші дії

Тепер давайте подивимось на код.

Почнемо з сьомого рядка. Як бачите, ми маємо звичайну функцію яка зовсім не залежить від нашого компоненту. Незважаючи на це, її обернули в useCallback мотивуючи тим що начебто

1. useCallback дозволяє не створювати нові екземпляри функції, що в свою чергу зберігає ресурси CPU та пам'яті
2. Rеакт зможе оптимізувати код і дочірні компоненти не будуть ре-рендеритися

І це наш перший код смелл - використання useCallback для функцій які зовсім не залежать від компоненту.

Причина, чому так робити не варто полягає в наступному.

Як би ви не хотіли, але для того, щоб передати в useCallback екземпляр функції, цю функцію потрібно створити і вона буде створюватися на кожен рендер. Проілюструвати це досить просто, достатньо винести цю функцію в окрему змінну і все стане очевидно наприклад ось так:

код.

Тож, як бачите дана оптимізація робить лише гірше. Вона не лише не прибирає створення зайвої функції, навпаки, створює зайве наватаження через виклик хуку useCallback на кожен рендер та ще й погіршує читабельність нашого коду.

В даному випадку, було б набагато краще просто винести цю функцію за межі компоненту. Так і читабельність коду буде кращою та й швидкодія покращеться.

Друге пояснення полягало в тому, що якщо у нас буде незмінне посилання на функцію, то реакт зможе не робити зайві рендери дочірніх елементів. Це, нажаль, також не зовсім вірно.

Давайте подивимось на 11 рядок. Тут у нас є функція яка маніпулює зі стейтом і я передаю її у звичайний функціональний компонент. Я огорнув її в useCallback, залежностей в неї немає, тож посилання на неї буде завжди одне й те саме. Давайте подивимось чи зможе реакт оптимізувати рендер дочірнього компоненту автоматично?

Відкриваємо UI, натискаємо на кнопку і бачимо, що наш звичаний функціональний комопонент продовжує ре-рендиритися, ен зважаючи на те, що його пропси не змінюються, а стану він взагалі не має.

Річ у тім, що зазвичай, компоненти пере-виконуються завжди, коли перевиконується їх батечко. Неважливо це функціональні компоненти чи класові. Для того, щоб компоненти перерендерювалися лише зі зміною пропсів - їх треба для цього спеціально готутвати, чого ми зазвичай не робимо.

Отже, це і є наш другий CodeSmell - використання useCallback для не підготовлених компонентів.

А як щодо звичайний jsx елементів? Можливо є сенс використовувати useCallback разом і з ними, тим паче що їх може бути дійсно багато? Нажаль, ні. Річ у тім, що реакт не додає колбеки до ваших компонентів напряму. Якщо ми виконаємо метод `window.getEventListeners($0).click[0].listener.toString()` на якійсь кнопці де є onClick, ви побачите, що колбек на ній дійсно є, але це - пуста функція яка ніколи не змінюється! Тому і тут особливої користі не спостерігається.

Тож використання useCallback для звичайних JSX елементів є третьою ознакою не найкращого коду.

Тепер постає логічне питання, а коли все таки є сенс використовувати useCallback?

Давайте почнемо з прикладу: Маємо комопонет `OptimizedButtonComponent`. Він огорнутий в memo і містить в собі пустий цикл на 3 мільярди ітерацій для симуляції складної роботи. Тепер перейдемо на UI, і покалацаємо на counter. Як бачите все працює без жодних проблем. Але, якщо ми приберемо useCalback то ситуація суттєво погіршиться, наш UI почне зависати, тому що OptimizedButtonComponent буде перерендирюватися на кожну зміну каунтера і своїм циклом блокувати головний потік виконнаня javascript-а

Умова перша - рендер компоненту, куди ви передаєте useCallback має займати відносно багато часу, наприклад час відведений на 3 кадри тобто 50ms. Або ж таких комопонентів на сторінці багато і сума їх рендерів також дорівнює 50ms. Цифри орієнтовні, ви можете покладатися React Profiler щоб виміряти час рендеру та Chrome Profiler щоб побачити де ви просідаєте нижче ідеальних 60fps.

Умова друга - компонент, який отримує оптимізований колбек, має рендеритися лише тоді, коли дані що він відображає, змінюються. Іншими словами компонент має бути огорнутим в memo, бути PureComponent, або реалізовувати метод ShouldComponentUpdate. В іншому випадку він ваші зусилля просто не помітить.

Гарними кандидатами на оптимізацію можуть бути datepicker, складні select-и, гріди, тощо.

Давайте підведемо підсумки

- useCallback це хук призначений для оптимізації швидкодії.
- Не використовуйте useCallback для звичайних JSX елементів або не підготовлених компонентів, це не принесе ніякої користі
- Перед оптимізаціями - вимірюйте час, який потрібен вашому компоненту для ре-рендеру

На цьому у мене все, до наступної зустрічі з React Code Smells!

Давайте подивимось на прикладі.

Як бачите, незважаючи на те, що ми використали useCallback, RegularButton продовжує перерендерюватися коли змінюється state батька. Хоча її пропси при цьому не змінюються. Для того, щоб запобігти цій поведінці, можна використовувати метод memo або PureComponents або реалізувати метод shouldComponentUpdate в класовому компоненті. Але не поспішайте це робити, будь-яка оптимізація вимагає від вас розуміння що ви робите і навіщо. Нашкодити досить просто.

І, нарешті, останній приклад зі звичайними, не компонентними, кнопками. Можливо, використання useCallback принесе якусь користь тут? Нажаль, ні. Річ у тім, що реакт не додає колбеки до ваших компонентів напряму. Якщо ми виконаємо метод window.getEventListeners на якійсь кнопці де є onClick, ви побачите, що колбек на ній дійсно є, але це - пуста функція яка ніколи не змінюється! Тому і тут особливої користі не спостерігається.

То ж постає питання - а коли ж є сенс використовувати useCallback?

По-перше, якщо ми передаємо цей колбек в складний (наголошую, складний!) компонент, який рендериться лише коли його пропси змінюються. Тут дійсно можна буде отримати непоганий результат. До-речі, в реакті є спеціальне АПІ яке дозволяє ...

Використання useCallback також може мати сенс в загальних кастомних хуках. Але не для чого-попало, а для фіксації екземпляра функції яку цей хук повертає. Якщо ви

які повертають якусь функцію. Наголошую - в загальних, тобто таких які можуть використовуватися по всій апці. Це дасть вам змогу передавати

На цьому у мене все - бережіть себе і до зустрічі наступного разу.
